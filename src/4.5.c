/********************************************************************
* 文件名  ： 独立按键.c
* 描述    :  首先，在点阵的中间显示一个点。
             当您按独立按键的下方或者左右的时候，点阵会随之移动。
***********************************************************************/
#include<reg52.h>
#include<intrins.h>
#define uchar unsigned char
#define uint  unsigned int

sbit KEY1 = P3^2;    //点左移
sbit KEY2 = P3^3;    //点下移
sbit KEY3 = P3^4;	 //点右移

unsigned char tabP0[]={0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00};
unsigned char tabP2[]={0x7F,0xBF,0xDF,0xEF,0xF7,0xFB,0xFD,0xFE};
/********************************************************************
* 名称 : Delay_1ms()
* 功能 : 延时子程序，延时时间为 1ms * x
* 输入 : x (延时一毫秒的个数)
* 输出 : 无
***********************************************************************/
void Delay_1ms(uint i)//1ms延时
{
	uint x,j;
	for(j=0;j<i;j++)
	for(x=0;x<=148;x++);	
}

/********************************************************************
* 名称 : Delay()
* 功能 : 实现按键功能，并在LED上显示
* 输入 : 无
* 输出 : 无
***********************************************************************/
uchar KEY(void)
{
	if(KEY1==0 || KEY2==0 || KEY3==0)	
	{
		Delay_1ms(20);   		//20毫秒软件防抖
		if(KEY1 == 0)
		{ 
			Delay_1ms(100);			//延时0.5秒再进行下次按键的检测
			return 1; 
		}
		if(KEY2 == 0)
		{			
			Delay_1ms(100);			//延时0.5秒再进行下次按键的检测
			return 2;
		}
		if(KEY3 == 0)
		{			
			Delay_1ms(100);			//延时0.5秒再进行下次按键的检测
			return 3;  
		}
		return 0;
	}
	return 0;	
}
/********************************************************************
* 名称 : Main()
* 功能 : 实现按键控制LED的显示
* 输入 : 无
* 输出 : 无
***********************************************************************/
void Main(void)
{
	uchar i,j,tempP0;
	while(1)
	{
		 for(i=0; i<8; i++)
		 {
		 	if(tabP0[i] != 0)
			{
				tempP0 = i;				  				  //这里的目的是找出现在的点在哪行
			}
		 }
		 
		 switch(KEY())
		 {
		 	case 1:					
				if(tempP0 != 7)							   //没有到边
				{	
					tabP0[tempP0+1]=tabP0[tempP0];		   //把数据传给数组的另一位
					tabP0[tempP0]=0x00;					   //本身的这位清零
				} 	
				break;
			case 2:
				j=tabP0[tempP0]; 							//把j的值左移一位
				j = _crol_(j,1);						  
				tabP0[tempP0]=j;				
				break;
			case 3:	
				if(tempP0 != 0)					 			//没有到边
				{
					tabP0[tempP0-1]=tabP0[tempP0];			//把数据传给数组的另一位
					tabP0[tempP0]=0x00;						//本身的这位清零
				}	
				break;		
			default:
				break;

		 }
		 for(i=0;i<8;i++)
		 {
			P0=0;
			P2=tabP2[i];
			P0=tabP0[i];
			Delay_1ms(2);
		 }	
	}
}
